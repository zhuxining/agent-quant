"""Shared dataclasses and data structures used across quant modules."""

from __future__ import annotations

from collections.abc import Mapping
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any


@dataclass(slots=True)
class MarketBar:
	"""Represents a single OHLCV bar for a trading symbol."""

	symbol: str
	timestamp: datetime
	open: float
	high: float
	low: float
	close: float
	volume: float


@dataclass(slots=True)
class IndicatorSnapshot:
	"""Collection of indicator values calculated for a symbol at a point in time."""

	symbol: str
	timestamp: datetime
	values: dict[str, Any] = field(default_factory=dict)
	metadata: dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class TradeSignal:
	"""Decision produced by an Agent for a particular symbol."""

	symbol: str
	side: str  # BUY, SELL, or HOLD
	quantity: float
	confidence: float
	metadata: dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class PositionSnapshot:
	"""Snapshot details for a single position."""

	symbol: str
	quantity: float
	avg_price: float
	last_price: float | None = None

	def market_value(self, price: float | None = None) -> float:
		"""Return the market value using the provided or cached price."""
		reference_price = price if price is not None else self.last_price or 0.0
		return reference_price * self.quantity

	def as_dict(self) -> dict[str, float]:
		"""Serialize to a lightweight mapping for logging or JSON."""
		return {
			"symbol": self.symbol,
			"quantity": self.quantity,
			"avg_price": self.avg_price,
			"last_price": self.last_price or 0.0,
		}


@dataclass(slots=True)
class AccountSnapshot:
	"""Snapshot of account balances and positions."""

	cash: float
	positions: dict[str, PositionSnapshot] = field(default_factory=dict)
	realized_pnl: float = 0.0
	timestamp: datetime = field(default_factory=datetime.utcnow)

	def position_quantity(self, symbol: str) -> float:
		"""Return the current quantity for the given symbol."""
		position = self.positions.get(symbol)
		return position.quantity if position else 0.0

	def equity(self, pricing: Mapping[str, float] | None = None) -> float:
		"""Calculate net equity using optional pricing data."""
		pricing = pricing or {}
		holdings = sum(
			position.market_value(pricing.get(symbol))
			for symbol, position in self.positions.items()
		)
		return self.cash + holdings


@dataclass(slots=True)
class PromptPayload:
	"""Prompt and supplemental metadata passed to an Agent."""

	content: str
	metadata: dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class AgentResponse:
	"""Response returned by an Agent prior to signal validation."""

	raw_text: str
	signals: list[TradeSignal] = field(default_factory=list)
	latency_ms: int | None = None
	metadata: dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class ExecutedTrade:
	"""Executed trade record stored for auditing and analytics."""

	symbol: str
	side: str
	quantity: float
	price: float
	executed_at: datetime = field(default_factory=datetime.utcnow)
	realized_pnl: float = 0.0
	metadata: dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class BacktestReport:
	"""Aggregate metrics generated by the backtest engine."""

	started_at: datetime
	ended_at: datetime
	metrics: dict[str, float] = field(default_factory=dict)
	artifacts: dict[str, Any] = field(default_factory=dict)
